<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; img-src data:; script-src 'unsafe-inline';">
<title>Search for Life — v10 • Pixel</title>
<style>
html,body{margin:0;padding:0;background:#000;height:100%;overflow:hidden}
canvas{image-rendering:pixelated;width:100vw;height:100vh;display:block}
#hud{position:fixed;left:4px;top:4px;color:#0ff;background:rgba(0,0,0,.4);padding:4px;font:12px monospace;white-space:pre}
</style>
</head>
<body>
<noscript><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGBgAAAABQABDQottAAAAABJRU5ErkJggg=="/></noscript>
<canvas id="c"></canvas>
<pre id="hud"></pre>
<script>
/* Pixel art Search for Life — deterministic 2D sprite prototype */
(function(){
const canvas=document.getElementById('c');
const hud=document.getElementById('hud');
let ctx;
let DPR=1, W=0, H=0, SCALE=4;
function fit(){
  DPR=1; // keep logical pixels
  W=Math.floor(innerWidth/SCALE);
  H=Math.floor(innerHeight/SCALE);
  canvas.width=W;
  canvas.height=H;
  canvas.style.width=W*SCALE+'px';
  canvas.style.height=H*SCALE+'px';
  ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=false;
}
fit(); addEventListener('resize',fit,{passive:true});

/* deterministic PRNG */
function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^b>>>9;b=c+(c<<3)|0;c=c<<21|c>>>11;c=c+t|0;return (t>>>0)/4294967296}}
function hash128(str){
 let h1=1779033703,h2=3144134277,h3=1013904242,h4=2773480762;
 for(let i=0;i<str.length;i++){
   let k=str.charCodeAt(i);
   h1=h2+h1^(k); h2=h3+h2^(k); h3=h4+h3^(k); h4=h1+h4^(k);
 }
 h1|=0; h2|=0; h3|=0; h4|=0;
 return [h1>>>0,h2>>>0,h3>>>0,h4>>>0];
}
const seedStr=(window.tokenData && window.tokenData.hash)|| (location.hash.slice(1)||'pixel');
const [a,b,c,d]=hash128(seedStr);
const PRNG=sfc32(a,b,c,d);
function rand(){return PRNG();}
function randRange(min,max){return min+(max-min)*rand();}

/* sector management */
const SECTOR=256;
const viewRange=1; // 3x3 grid
const sectors=new Map();
function sectorKey(x,z){return x+','+z;}
function getSector(ix,iz){
  const k=sectorKey(ix,iz);
  if(sectors.has(k)) return sectors.get(k);
  // deterministically fill stars
  const h=sfc32(ix*1664525,iz*1013904223,ix*374761393,iz*668265263);
  const starCount=10+Math.floor(h()*20);
  const stars=[];
  for(let i=0;i<starCount;i++){
    const sx=(h()*SECTOR);
    const sy=(h()*SECTOR);
    const sz=(h()*SECTOR);
    const cls=h(); // spectral
    let color='#fff';
    if(cls<0.7) color='#fff';
    else if(cls<0.85) color='#ff9';
    else if(cls<0.95) color='#9cf';
    else color='#f99';
    stars.push({x:sx,y:sy,z:sz,color,alpha:0});
  }
  const sec={ix,iz,stars};
  sectors.set(k,sec);
  return sec;
}

/* player state */
let px=0,py=0,pz=0;
let yaw=0;
let vel=0;
let throttle=0;
let warp=false;

/* controls */
const keys=new Set();
addEventListener('keydown',e=>{keys.add(e.key.toLowerCase()); if(e.key==='h'){hud.hidden=!hud.hidden;}});
addEventListener('keyup',e=>{keys.delete(e.key.toLowerCase());});

canvas.addEventListener('click',()=>{canvas.requestPointerLock();});
addEventListener('pointerlockchange',()=>{});
addEventListener('mousemove',e=>{
 if(document.pointerLockElement!==canvas) return;
 yaw+=e.movementX*0.002;
});

/* update loop */
function step(dt){
  if(keys.has('w')) throttle=Math.min(1,throttle+dt);
  if(keys.has('s')) throttle=Math.max(0,throttle-dt);
  if(keys.has('a')) yaw-=dt;
  if(keys.has('d')) yaw+=dt;
  const maxSpeed=warp?200:40;
  if(keys.has('shift') && throttle>0.8) warp=true;
  if(keys.has('j')) warp=!warp;
  vel+=throttle*80*dt;
  vel*=0.98;
  if(vel>maxSpeed) vel=maxSpeed;
  const dx=Math.sin(yaw)*vel*dt;
  const dz=Math.cos(yaw)*vel*dt;
  px+=dx; pz+=dz;
}

/* drawing */
function draw(){
 ctx.fillStyle='#000';
 ctx.fillRect(0,0,W,H);
 const secX=Math.floor(px/SECTOR);
 const secZ=Math.floor(pz/SECTOR);
 for(let gx=secX-viewRange; gx<=secX+viewRange; gx++){
  for(let gz=secZ-viewRange; gz<=secZ+viewRange; gz++){
    const sec=getSector(gx,gz);
    for(const star of sec.stars){
      const sx=gx*SECTOR+star.x;
      const sz=gz*SECTOR+star.z;
      const dx=sx-px;
      const dz=sz-pz;
      const rx=Math.cos(-yaw)*dx - Math.sin(-yaw)*dz;
      const rz=Math.sin(-yaw)*dx + Math.cos(-yaw)*dz;
      if(rz<=0) continue;
      const scale=80/rz;
      const x=W/2 + rx*scale;
      const y=H/2 - star.y*scale;
      if(x<0||x>=W||y<0||y>=H) continue;
      star.alpha=Math.min(1,star.alpha+0.05);
      ctx.fillStyle=star.color;
      ctx.globalAlpha=star.alpha;
      ctx.fillRect(Math.floor(x),Math.floor(y),1,1);
      ctx.globalAlpha=1;
    }
  }
 }
 if(warp){
   ctx.fillStyle='rgba(0,128,255,0.2)';
   for(let i=0;i<50;i++){
     const ang=Math.random()*Math.PI*2;
     const len=randRange(10,40);
     const x=W/2+Math.cos(ang)*len;
     const y=H/2+Math.sin(ang)*len;
     ctx.fillRect(x,y,1,1);
   }
 }
 hud.textContent=`pos ${px.toFixed(1)},${pz.toFixed(1)}\nvel ${vel.toFixed(1)} yaw ${yaw.toFixed(2)}\nthr ${(throttle*100)|0}% warp ${warp?'on':'off'}`;
}

let last=performance.now();
function loop(now){
 const dt=(now-last)/1000;
 last=now;
 step(dt);
 draw();
 requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
